{"version":3,"sources":["api/index.js","components/Feature.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromURL","url","a","fetch","response","json","data","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Feature","props","featuredResult","title","dated","images","primaryimageurl","culture","description","medium","style","technique","dimensions","people","department","division","contact","creditline","console","log","id","className","Fragment","map","person","picture","src","Preview","setSearchResults","setFeaturedResult","setIsLoading","searchResults","info","fetchPage","pageUrl","results","error","disabled","prev","onClick","next","record","index","key","event","preventDefault","alt","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","onSubmit","htmlFor","type","placeholder","value","onChange","target","length","name","option1","option2","Title","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9f05a5d6.chunk.js","sourcesContent":["import React from \"react\";\nimport ReactDOM from 'react-dom';\n\n\n\n/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=641801d0-e2d5-4766-be4d-716d8556ea85';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    // const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  } \n}\n\n\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n","import { atRule } from 'postcss';\nimport React, { Fragment } from 'react';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = (props) => {\n    const {searchTerm} = props.term; // const searchTerm = props.term\n    const {searchValue} = props.value; // const searchValue = props.value\n    const {setIsLoading} = props;   // const setIsLoading = props.setIsLoading\n    const {setSearchResults} = props; // const setSearchResults = props.setSearchResults\n\n    return (\n         <span className=\"content\">\n         <a href=\"#\" onClick={async (event) => {\n             event.preventDefault();\n             setIsLoading(true);\n        try {\n             const termAndValue = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue);\n             return setSearchResults(termAndValue);\n            } catch (error) {\n                console.error(error)\n            } finally {\n                setIsLoading(false)\n            };\n         }}>{searchTerm}</a>\n         </span>\n    )\n}\n\n// /**\n//  * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n//  * \n//  * <main id=\"feature\"></main>\n//  * \n//  * And like this when one is:\n//  * \n//  * <main id=\"feature\">\n//  *   <div className=\"object-feature\">\n//  *     <header>\n//  *       <h3>OBJECT TITLE</h3>\n//  *       <h4>WHEN IT IS DATED</h4>\n//  *     </header>\n//  *     <section className=\"facts\">\n//  *       <span className=\"title\">FACT NAME</span>\n//  *       <span className=\"content\">FACT VALUE</span>\n//  *       <span className=\"title\">NEXT FACT NAME</span>\n//  *       <span className=\"content\">NEXT FACT VALUE</span>\n//  *     </section>\n//  *     <section className=\"photos\">\n//  *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n//  *     </section>\n//  *   </div>\n//  * </main>\n//  * \n//  * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n//  * technique, medium, dimensions, people, department, division, contact, creditline\n//  * \n//  * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n//  * \n//  * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n//  * \n//  * This component should be exported as default.\n//  */\nconst Feature = (props) => {\n    const {featuredResult} = props;\n    const {title, dated, images, primaryimageurl, description, culture, style, technique, medium,\n           dimensions, people, department, division, contact, creditline} = props.featuredResult;\n\n           console.log(featuredResult);\n    return (\n     \n        featuredResult ? <main id=\"feather\"> </main> :\n          <main id=\"feature\">\n      \n            <div className=\"object-feature\">\n                 <header>\n                     <h3>{title}</h3>\n                     <h4>{dated}</h4>\n                 </header>\n            <section className=\"facts\">\n\n            <React.Fragment>\n                 <span className=\"title\">{culture}</span>\n                 <span className=\"content\">FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{medium}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{dimensions}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span> \n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{people}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{department}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{division}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{contact}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n\n            <React.Fragment>\n                 <span className=\"title\">{creditline}</span>\n                 <span className=\"content\">NEXT FACT VALUE</span>\n            </React.Fragment>\n     \n            {people.map((person) => {\n                return person;\n            })}\n\n            {images.map((picture) => {\n                return picture;\n            })}\n            </section>\n                <section className=\"photos\">\n                     <img src={primaryimageurl}  />\n                </section>\n            </div>\n         </main>\n    )\n}\n\nexport default Feature;","import React from 'react';\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\nconst Preview = (props) => {\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * \n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n    const {setSearchResults} = props; // const setSearchResults = props.setSearchResults\n    const {setFeaturedResult} = props; // const setFeaturedResult = props.setFeaturedResult\n    const {setIsLoading} = props; // const setIsLoading = props.setIsLoading\n    const {info, records} = props.searchResults; // const info = props.searchResults.info\n                                                 // const records = props.searchResults.records\n  /**\n   * Don't touch this function, it's good to go.\n   * \n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    //   console.log(props.searchResults)\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  console.log(props.searchResults);\n\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n      <button \n        disabled={info.prev ? false : true} \n        className=\"previous\"\n        onClick={() => fetchPage(info.prev)}>Previous</button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n      <button\n        disabled={info.next ? false : true}\n        className=\"next\"\n        onClick={() => fetchPage(info.next)}>Next</button>\n    </header>\n    <section className=\"results\">\n      {\n        /* Here we should map over the records, and render something like this for each one: */\n        records.map((record, index) => {\n            return (\n                <div  \n                key={ index }\n                className=\"object-preview\"\n                onClick={(event) => {\n                  // prevent the default\n                  event.preventDefault();\n                  // set the featured result to be this record, using setFeaturedResult\n                  setFeaturedResult(record);\n                }}>\n                { \n                  // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n                    record.primaryimageurl ? <img src={ record.primaryimageurl } alt={ record.description } /> : \"\"\n                }\n                {\n                  // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n                  record.title ? <h3>{ record.title }</h3> : <h3> MISSING INFO </h3>\n                }\n              </div>\n            );\n        })\n         \n      }\n    </section>\n  </aside>\n}\n\nexport default Preview;","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n\n  const {setIsLoading} = props;     // const setIsLoading = props.setIsLoading\n  const {setSearchResults} = props; // const setSearchResults = props.setSearchResults\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * \n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   */\n\n  const [centuryList, setCenturyList] = useState([]);\n\n  const [classificationList, setClassificationList] = useState([]);\n\n  const [queryString, setQueryString] = useState(\"\");\n\n  const[century, setCentury] = useState(\"any\");\n\n  const [classification, setClassification] = useState(\"any\");\n\n  \n  useEffect(() => {\n\n    Promise.all([fetchAllCenturies(), fetchAllClassifications()]).then((data) => {\n      setCenturyList(data[0])\n      setClassificationList(data[1]);\n    });\n  }, []);\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n  return <form id=\"search\" onSubmit={async (event) => {\n    // write code here\n    event.preventDefault();\n    setIsLoading(true);\n    try {\n      const results = await fetchQueryResults({century, classification, queryString});\n      return setSearchResults(results);\n    } catch (error) {\n      console.error(error)\n    } finally {\n      setIsLoading(false)\n    }\n  }}>\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={queryString} /* this should be the query string */\n        onChange={(event) => setQueryString(event.target.value) } />\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification} \n        onChange={(event) => setClassification(event.target.value)}>\n        <option value=\"any\">Any</option>\n        {/* map over the classificationList, return an <option /> */}\n        {classificationList.map((option1) => {\n          //console.log(option1);\n          return (\n            <option key={option1.id} value={option1.name}> {option1.name} </option>\n          );\n        })}\n      </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={century} /* this should be the century */\n        onChange={(event) => setCentury(event.target.value)}>\n        <option value=\"any\">Any</option>\n        {/* map over the centuryList, return an <option /> */}\n        {centuryList.map((option2) => {\n          return (\n            <option key={option2.id} value={option2.name}> {option2.name} </option>\n          );\n        })}\n      </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\n\nexport default Search;","import React from 'react';\n\nconst Title = () => {\n    return (\n        <div id=\"title\">\n    <h1>\n      The Art Collector\n    </h1>\n    <h5>\n      Search the Harvard Art Museums' Private Collections\n    </h5>\n  </div>\n    ); \n}\n  \n \nexport default Title;","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n\n// These imports won't work until you fix ./components/index.js\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\n\nconst App = () => {\n\n  const [searchResults, setSearchResults] = useState({info: {}, records: []});\n\n  const [featuredResult, setFeaturedResult] = useState({});\n\n  const [isLoading, setIsLoading] = useState(false);\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search setIsLoading={setIsLoading} setSearchResults={setSearchResults} />\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview searchResults={searchResults} setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult} />\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    <Feature featuredResult={featuredResult} setIsLoading={setIsLoading} />\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    {/* <Loading /> */}\n    \n  </div>\n}\n\nReactDOM.render(\n  <App />,\n  document.getElementById('app')\n)\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */"],"sourceRoot":""}